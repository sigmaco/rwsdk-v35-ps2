[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.1
                  Copyright (C) 2000 by Sony Computer Entertainment Inc.
                                                     All Rights Reserved

"PlayStation" 用音声付き MPEG2 ストリーム(PSS)の再生


<サンプルの解説>
---------------

    == 概要 ==

    mpegstr は、"PlayStation" 用音声付き MPEG2 ストリーム(PSS)
    の再生サンプルプログラムです。mpegstr では、次の要求を満たす
    映像及び音声を再生します。

    - 映像 -

	Main Profile at Main Level(MP@ML)
	Simple Profile at Main Level(SP@ML)
	最大サイズ               :720x576
	ピクチャ構造             :フレーム構造(プログレッシブ
					       フレームが望ましい)

    - 音声 -

	形式                      :ストレートPCM
	サンプル長                :16bit
	エンディアン              :リトルエンディアン
	サンプリングレート        :48.0KHz
	チャネル数                :2
	(L/R)インターリーブサイズ :512

    mpegstr はホストのハードディクドライブまたは、DTL-T10000
    の CD/DVD ドライブに置かれた PSS ファイルを再生します。再生
    もとのデバイスはファイル名の先頭のデバイス名(host0:/cdrom0:)
    で指定します。

    映像と音声の多重化には、ストリームコンバータ ps2str を使用しま
    す。本プログラムの再生するストリームのストリーム番号は
    映像/音声共に 0 である必要があります。多重化のときには、スト
    リーム番号に 0 を指定します。


    == GS のメモリについて ==
	
    本プログラムでは最初に GS のメモリの初期化を行ない、その後
    通常のダブルバッファの設定を行なっています。

    (a) clearGsMem 関数
	まず GS のメモリの初期化を行います。
	メモリ全体を 1 つの大きな描画領域として設定し、1 枚のスプライトを
	描画することでこれを実現しています。

		 -----------------------
		|			|
		|			|
		|			|
		|			|
		|			|
		|			|
		|			|
		|			|
		|	Frame		|
		|	 Buffer		|
		|			|
		|			|
		|			|
		|			|
		|			|
		|			|
		|			|
		|			|
		|			|
		 -----------------------
    (b) sceGsSetDefDBuff 関数
	次に sceGsSetDefDBuff 関数を用いて、改めて GS のメモリを
	フレームバッファ、テクスチャバッファと設定しています。
	本サンプルでは Z バッファは使用しておりません。

		 -----------------------
		|			|
		|	Frame		|
		|	 Buffer0	|
		|			|
		 -----------------------
		|			|
		|	Frame		|
		|	 Buffer1	|
		|	 		|
		 -----------------------
		|			|
		|	Texture		|
		|	 Buffer		|
		|			|
		|			|
		 -----------------------
		|			|
		|			|
		|			|
		 -----------------------

    == スレッド構成 ==

    プログラムは 3 つのスレッドからできています。

    (a) main thread 
    main thread は、main() が実行されるスレッドです。main thread は
    初期化および他のスレッドを作成/起動した後、次の処理を行います。

	+ データをメディアから readBuf に読み込む。
	+ readBuf のデータを非多重化し、絵を videoDec の viBuf へ、
	  音声を audioDec 内のバッファへ転送する。
	+ DMA 使って絵を IPU に送る。
	+ 音声を IOP 側に送る。

    (b) video decode thread 
    video decode thread は、IPU を使って絵のデコードを行います。

	+ IPU を使って絵のデコードをする。
	+ デコード結果は voBuf に蓄える。

    (c) default thread 
    default thread はデバッグ目的で使用します。他のスレッドと同様に
    制御が回ってきますが通常は何もしません。


    == 割り込み ==

    本プログラムはユーザ側で 2 つの割り込みを使用しています。

    (a) vblankHandler
	vblank の開始時にこの関数が呼ばれます。関数内では、

	- sceGsSetHalfOffset を使用して odd フィールドと even フィールドの
	  間に生じるハーフピクセルのずれを調節。
	- sceGsSwapDBuff を使用してダブルバッファの切替え。
	- sceDmaSend を使用して画像データと描画に必要なデータをGS に転送。

	という処理を行なっています。vblank が 2 回発生する間に 1 度だけ
	画像データを GS に転送するため odd フィールドと even フィールド
	では同じ画像がテクスチャとして参照されます。しかし毎回の
	vblank 毎にダブルバッファを入れ換えているため動作は 60 frames/s
	になっています。

    (b) hadler_endimage
	path3 経由の DMA 転送が終了した時に割り込みが発生し、この関数が
	呼ばれます。メインループの中では画像データの転送と、sceGsSwapDBuff
	の中で path3 経由の DMA が使用されていますが、フラグによって
	区別をしているため、sceGsSwapDBuff による DMA が終了した際には、
	この関数は何もしないで抜けてしまいます。画像データの転送が
	終了した際には、フラグがたち、この関数は、

	- VoBuf 内にある画像の数を示すカウンターを 1 減らす。
	- フレームの描画が終了したことを示すフラグを立てる。

	という処理を行ないます。これによって VoBuf 内にある
	画像データの数を管理しています。


    == プログラムの大まかな流れ ==

    本プログラムは 3 つのスレッド及び 2 つの割り込みハンドラを
    使用しているため、プログラムの流れがつかみにくいですが、
    簡単に示すと以下のようになります。下記「データの流れ及びバッファ構成」
    と共に御参照下さい。

    (a) SIF の初期化および必要なモジュールを IOP メモリ上にロード。

    (b) GS のメモリの初期化後、フレームバッファ、テクスチャバッファを設定。

    (c) ディスクから取ってきたデータ( 音声 + 画像 )を格納するバッファ
	readBuf を確保。
	
    (d) 音声及び画像のデコーダ( videoDec, audioDec )を作成。

    (e) IPU を使ってデコードした後の画像データを格納するバッファ
	VoBuf を確保。

    (f) 2 つのスレッド( default, video decode 詳しくは上記を参照 )を作成。

    (g) ストリーミングを行なうファイルを開く。

    (h) 2 つの割り込みハンドラを登録。
	( vblankHandler, handler_endimage 詳しくは上記を参照 )

    (i)	readBuf に ディスクからデータを転送。

    (j) sceMpegDemuxPssRing を用いてデータを音声と画像に非多重化。

    (k) 音声データは IOP に送り返す。

    (l) sceMpegGetPicture を用いて画像データをデコード。

    (m) デコードした画像データと描画データをGS に送るためのパケットを作成。

    (n) フラグを立てて vblankHandler が処理を行なうように設定。

    (o) 音声データのデコード開始。

    (p) vblank ごとに描画、表示バッファを切替えて、パケットを GS に転送。

    (q) データがなくなるまで (i) から (p) を繰り返す。


    == データの流れおよびバッファ構成 ==

    データを CD/DVD から読み込みそれを再生するまでのデータの流れは下図の
    通りです。


            audioDec  readBuf   viBuf           voBuf
            +---+     +---+     +---+           +---+
            | A |     | V |---->| V |  Video    |   |
            +---+     +---+     +---+  decode   | V |
            | A |<----| A |     | V |--> IPU -->|   |--> GS
            +---+     +---+     +---+           +---+
              |       | V |     | V |           |   |
              |       +---+     +---+           | V |
              |       | A |     |-------------| |   |
              |       +---+       videoDec      +---+
              |       | V |                    
              |       +---+                                        EE 
              |         ^
            --|---------|-----------------------------------------------
              V         |
            +---+       |                                          IOP
     SPU2<--| A |     CD/DVD/HD
            +---+
            | A |
            +---+

        (a) CD/DVD/HD から読み込まれたデータは、最初に EE 上のバッファ
            readBuf に置かれます。
        (b) readBuf のデータは、非多重化され、音と絵に分解されます。
        (c) 絵は videoDec モジュール中のビデオ入力バッファ viBuf に送
	    られます。
        (d) viBuf のデータは IPU を使ってデコードされ、デコード後の絵
	    はビデオ出力バッファ voBuf に置かれます。
        (e) voBuf 上の絵は vblank 割り込みに同期して GS に送られ、
	    モニタに表示されます。
        (f) (b) で非多重化された音は、audioDec モジュール中のバッファに
            保存されます。
        (g) audioDec に保存された音は、IOP 側(SMEM)のバッファに転送さ
	    れます。
        (h) SMEM 上の音は SPU2 のローカルメモリに DMA 転送され、そこで
	    再生されます。


    == その他 ==

    本サンプルプログラムでは、映像/音声のタイムスタンプを
    チェックしていません。そのため、同期がずれた場合の復帰動作は
    組み込まれていません。本プログラムでは、映像/音声の先頭を合わ
    せた後、再生を開始します。映像の再生速度は vblank が決めます。
    音声の再生速度は、SPU2 の再生速度が決めます。両者には僅かな誤
    差があることがありますが、通常の再生においては問題にならない程
    度です。

    pause/resume を行った場合、音声に関しては最大で 512 サンプル
    (48KHz で 0.0107 sec) 欠落する可能性があります。

    read が間に合わない、または、デコードが間に合わない等の理由に
    より途中のバッファがアンダーフローした場合には、それまでにデ
    コードされたデータが繰り返し再生されます。すなわち、映像に
    関しては、最後にデコードされた絵がそのまま表示されます。音声
    に関してはバッファに残っているデータが繰り返し再生されます。
    このとき、音声と映像の同期がずれる可能性があります。また、バッ
    ファが一杯である限り、新たなデータの取り込みをしませんので、
    バッファがオーバーフローすることはありません。

    関数 sceMpegGetPicture() は、内部で SPR(Scratch Pad RAM) を
    使用します。このため、他で SPR を使う場合には
    sceMpegGetPicture() の間は SPR を開放する必要があります。

<ファイル>
	audiodec.c
	audiodec.h
	defs.h
	disp.c
	disp.h
	main.c
	read.c
	readbuf.c
	readbuf.h
	strfile.c
	strfile.h
	util.c
	vibuf.c
	vibuf.h
	videodec.c
	videodec.h
	vobuf.c
	vobuf.h

<起動方法>
	% make		: コンパイル
	% make run	: 実行(音声付き)
	% make noaudio  : 実行(音声なし)
	% make help     : help情報表示(ファイル名の指定方法を確認できます)


	ホストのハードディスクドライブに PSS ファイルがある場合は、例えば
	以下のように実行します。

	% dsreset 0 0
	% dsedb
	dsedb S> run main.elf 'host0:XXX.pss’
'
	また、DTL-T10000 の CD/DVD ドライブに PSS ファイルがある場合は、
	例えば以下のように実行します。

	% dsreset 0 0
	% dsedb
	dsedb S> run main.elf 'cdrom0:\\XXX.PSS;1’


<コントローラの操作方法>
	○ボタン　: 初めから再生
	×ボタン  : 終了 
	口ボタン  : pause/resume

<備考>
	(a) DTL-T10000 を用いてホスト側からストリーミングする際に
	    は、ネットワークの負荷により再生が乱れることがあります。
	    ネットワークを介してストリーミングする際には、
	    次の点にご注意ください。

		100Base-T 接続にする
		ハブ等を介さない

	(b) /usr/local/sce/data/movie/mpeg/sample.pss のサンプルデータは、
	    画像の一部に乱れがあります。


